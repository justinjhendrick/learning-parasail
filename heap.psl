interface Heapable<> is
    type Full_Ordering is Ordering {Full_Ordering in [#less, #equal, #greater]}
    op "=?"(Left, Right : Heapable) -> Full_Ordering
    func To_String(Val : Heapable) -> Univ_String
end interface Heapable;

//--------TODO---------------------
//  test |= and Pop thoroughly
//  test To_String_Tree thoroughly
//---------------------------------
concurrent interface Heap<E is Heapable<>> is
    //log(n) insertion and removal heap implemented on ZVector
    //Left child is located at 2 * n + 1
    //Right child is located at 2 * n + 2 where n is the index of the current node
    //Parent is located at (n - 1) / 2
    //This allows the tree to be represented as an array
    op "[]"() -> Heap;
        //create empty Heap
    op "|="(locked var H : Heap; Elem : E);
        //adds element to heap
    func Create(P : Polarity) -> Heap;
        //creates a new empty heap with the given polarity
    func Length(H : Heap) -> Univ_Integer;
        //returns number of elements
    func Pop(locked var H : Heap) -> optional E;
        //pops highest priority from heap
        //return null if H is empty
    func To_String(H : Heap) -> Univ_String<>;
        //returns a string representation of the heap
end interface Heap;

concurrent class Heap is
        var Data : ZVector<E>;
        var Size : Univ_Integer;
        type Polarity is Ordering {Polarity in [#less, #greater]};
        const Pole : Polarity;

        //Preserve Heap Order (Parent relation to both children must match Pole)
        //Start at bottom and recurse up the tree
        func Preserve_Order_Up(locked var H : Heap; N : Integer) is
            if N == 0 then
                return;
            end if;
            const Parent_Index := (N - 1) / 2;
            const Child_Parent : Ordering := H.Data[N] =? H.Data[Parent_Index];
            if Child_Parent == H.Pole then
                H.Data[N] <=> H.Data[Parent_Index]
                Preserve_Order_Up(H, Parent_Index)
            end if;
        end func Preserve_Order_Up;

        //Recurses down the tree. Swaps nodes if necessary to preserve heap order
        func Preserve_Order_Down(locked var H : Heap; N : Univ_Integer) is
            const L := 2 * N + 1;
            if L >= H.Size then
                return;
            end if;
            const R := 2 * N + 2;
            const Has_Right : Boolean := R < H.Size;
            const Left_To_Parent : Ordering := H.Data[L] =? H.Data[N];
            var Right_To_Parent : Ordering;
            if Has_Right then
                Right_To_Parent := H.Data[R] =? H.Data[N];
            end if;
            if Left_To_Parent == H.Pole or
                    (Has_Right and then Right_To_Parent == H.Pole) then
                if Has_Right then
                    const Left_To_Right := H.Data[L] =? H.Data[R];
                    const Right_To_Left := H.Data[R] =? H.Data[L];
                    if Left_To_Right == H.Pole then
                        H.Data[N] <=> H.Data[L];
                        Preserve_Order_Down(H, L);
                    elsif Right_To_Left == H.Pole then
                        H.Data[N] <=> H.Data[R];
                        Preserve_Order_Down(H, R);
                    end if;
                else
                    H.Data[N] <=> H.Data[L];
                end if;
            end if;
        end func Preserve_Order_Down;

        //recursion for To_String
        func To_String_Helper(H : Heap; Low, High : Univ_Integer) -> Univ_String is
            const Len := High - Low;
            if Len == 0 then
                return "";
            elsif Len == 1 then
                return H.Data[Low].To_String();
            end if;
            const Half := Low + Len / 2;
            return H.To_String_Helper(Low, Half) | ", " | H.To_String_Helper(Half, High);
        end func To_String_Helper;

        func To_String_Tree(H : Heap) -> Univ_String is
            const Height := H.Tree_Height();
            var Width := 1;
            var Col := 0;
            var Row := 0;
            var Result : ZString := " " * (2**(Height - Row - 1));
            for I in 0 ..< H.Size forward loop
                Col += 1;
                if Col == 1 then
                    Row += 1;
                end if;
                Result |= H.Data[I].To_String() | " " * (2 * 2**(Height - Row) - 1);
                if Col == Width then
                    Result |= "\n" | " " * (2**(Height - Row - 1));
                    Width *= 2;
                    Col := 0;
                end if;
            end loop
            return Result;
        end func To_String_Tree;

        func Tree_Height(H : Heap) -> Univ_Integer is
            var Width := 1;
            var Height := 0;
            var Col := 0;
            for I in 0 ..< H.Size forward loop
                Col += 1;
                if Col == 1 then
                    Height += 1;
                end if;
                if Col == Width then
                    Width *= 2;
                    Col := 0;
                end if;
            end loop
            return Height;
        end func Tree_Height;

    exports
        op "[]"() -> Heap is
            return (Data => [], Size => 0, Pole => #less);
        end op "[]";

        op "|="(locked var H : Heap; Elem : E) is
            H.Data |= Elem;
            H.Size += 1;
            Preserve_Order_Up(H, H.Size - 1);
        end op "|=";

        func Create(P : Polarity) -> Heap is
            return (Data => [], Size => 0, Pole => P);
        end func Create;

        func Length(H : Heap) -> Univ_Integer is
            return H.Size;
        end func Length;

        func Pop(locked var H : Heap) -> optional E is
            if H.Size == 0 then
                return null;
            end if;
            H.Data[0] <=> H.Data[H.Size - 1];
            const To_Return <== H.Data[H.Size - 1];
            H.Size -= 1;
            Preserve_Order_Down(H, 0);
            return To_Return;
        end func Pop;

        func To_String(H : Heap) -> Univ_String<> is
            //return "[" | H.To_String_Helper(0, H.Size) | "]";
            return H.To_String_Tree();
        end func To_String;
end class Heap;


func Test() is
    type Int_Heap is Heap<Univ_Integer>;
    var H : Int_Heap := [];
    for J in 1 .. 3 forward loop
        for I in 1 .. 9 concurrent loop
            H |= I;
        end loop;
    end loop;
    Println(H.To_String());
    //for I in 0..<50 concurrent loop
    //    Print(H.Pop() | ", ");
    //end loop;
end func Test;

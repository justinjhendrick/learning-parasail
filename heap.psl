interface Heapable<> is
    type Full_Ordering is Ordering {Full_Ordering in [#less, #equal, #greater]}
    op "=?"(Left, Right : Heapable) -> Full_Ordering
    func To_String(Val : Heapable) -> Univ_String
end interface Heapable;

//--------TODO---------------------
//  test |= and Pop thoroughly
//  To_String_Tree
//      Size 0 or 1 heap
//      Limit size of Element To_String in To_String_Tree
//  Pre and Post Conditions
//  Which functions should be Locked?
//      Originally I thought only ones with (var H : Heap ...)
//      But read-only things like To_String could get an index OOB if another thread is editing the Heap
//---------------------------------
concurrent interface Heap<E is Heapable<>> is
    //log(n) insertion and removal heap implemented on ZVector
    //Left child is located at 2 * n + 1
    //Right child is located at 2 * n + 2 where n is the index of the current node
    //Parent is located at (n - 1) / 2
    //This allows the tree to be represented as an array
    op "[]"() -> Heap;
        //create empty Heap
    op "|="(locked var H : Heap; Elem : E);
        //adds element to heap
    func Create(P : Polarity) -> Heap;
        //creates a new empty heap with the given polarity
    func Length(H : Heap) -> Univ_Integer;
        //returns number of elements
    func Pop(locked var H : Heap) -> optional E;
        //pops highest priority from heap
        //return null if H is empty
    func To_String(H : Heap) -> Univ_String<>;
        //returns a string representation of the heap
    func To_String_Tree(locked H : Heap) -> Univ_String<>;
        //returns the elements organized into a tree in a ZString
end interface Heap;

concurrent class Heap is
        type Int_ZVector is ZVector<Univ_Integer>;
        type Str_Array is Array<ZString, Integer>;
        var Data : ZVector<E>;
        var Size : Univ_Integer;
        type Polarity is Ordering {Polarity in [#less, #greater]};
        const Pole : Polarity;

        //Preserve Heap Order (Parent relation to both children must match Pole)
        //Start at bottom and recurse up the tree
        func Preserve_Order_Up(locked var H : Heap; N : Integer) is
            if N == 0 then
                return;
            end if;
            const Parent_Index := (N - 1) / 2;
            const Child_Parent : Ordering := H.Data[N] =? H.Data[Parent_Index];
            if Child_Parent == H.Pole then
                H.Data[N] <=> H.Data[Parent_Index]
                Preserve_Order_Up(H, Parent_Index)
            end if;
        end func Preserve_Order_Up;

        //Recurses down the tree. Swaps nodes if necessary to preserve heap order
        func Preserve_Order_Down(locked var H : Heap; N : Univ_Integer) is
            const L := 2 * N + 1;
            if L >= H.Size then
                return;
            end if;
            const R := 2 * N + 2;
            const Has_Right : Boolean := R < H.Size;
            const Left_To_Parent : Ordering := H.Data[L] =? H.Data[N];
            var Right_To_Parent : Ordering;
            if Has_Right then
                Right_To_Parent := H.Data[R] =? H.Data[N];
            end if;
            if Left_To_Parent == H.Pole or
                    (Has_Right and then Right_To_Parent == H.Pole) then
                if Has_Right then
                    const Left_To_Right := H.Data[L] =? H.Data[R];
                    const Right_To_Left := H.Data[R] =? H.Data[L];
                    if Left_To_Right == H.Pole then
                        H.Data[N] <=> H.Data[L];
                        Preserve_Order_Down(H, L);
                    elsif Right_To_Left == H.Pole then
                        H.Data[N] <=> H.Data[R];
                        Preserve_Order_Down(H, R);
                    end if;
                else
                    H.Data[N] <=> H.Data[L];
                end if;
            end if;
        end func Preserve_Order_Down;

        //divide and conquer recursion for To_String
        func To_String_Helper(H : Heap; Low, High : Univ_Integer) -> Univ_String is
            const Len := High - Low;
            if Len == 0 then
                return "";
            elsif Len == 1 then
                return H.Data[Low].To_String();
            end if;
            const Half := Low + Len / 2;
            return H.To_String_Helper(Low, Half) | ", " | H.To_String_Helper(Half, High);
        end func To_String_Helper;


        //TODO: wait for ability to return multiple things
        //instead of passing widths as a var parameter
        //Computes the Height of the tree and returns a vector of tree widths
        //for use by To_String_Tree
        func Tree_Height(var Widths : Int_ZVector) -> Univ_Integer is
            var Width := 1;
            var Height := 0;
            var Col := 0;
            for I in 0 ..< Widths.Length() forward loop
                Widths[I] := Width;
                Col += 1;
                if Col == 1 then
                    Height += 1;
                end if;
                if Col == Width then
                    Width *= 2;
                    Col := 0;
                end if;
            end loop
            return Height;
        end func Tree_Height;

        //TODO: wait for ability to return multiple things
        //Return size of largest element to string
        //for use by To_String_Tree
        func To_Strings_Elem_Size(locked H : Heap; var Strings : Str_Array) -> Univ_Integer is
            var Max_Elem_Size := 0;
            for I in 0 ..< Strings.Length() forward loop
                const Size := H.Data[I].To_String().Length();
                if Size > Max_Elem_Size then
                    Max_Elem_Size := Size;
                end if;
            end loop;
            //TODO: Uncomment this once trimming is done
            //if Max_Elem_Size > 4 then
            //    Max_Elem_Size := 4;
            //end if;
            for I in 0 ..< Strings.Length() concurrent loop
                const Str := H.Data[I].To_String();
                Strings[I] := (" " * (Max_Elem_Size - Str.Length())) | Str;
                //TODO trim things longer than 4
            end loop;
            return Max_Elem_Size;
        end func To_Strings_Elem_Size;

    exports
        op "[]"() -> Heap is
            return (Data => [], Size => 0, Pole => #less);
        end op "[]";

        op "|="(locked var H : Heap; Elem : E) is
            H.Data |= Elem;
            H.Size += 1;
            Preserve_Order_Up(H, H.Size - 1);
        end op "|=";

        func Create(P : Polarity) -> Heap is
            return (Data => [], Size => 0, Pole => P);
        end func Create;

        func Length(H : Heap) -> Univ_Integer is
            return H.Size;
        end func Length;

        func Pop(locked var H : Heap) -> optional E is
            if H.Size == 0 then
                return null;
            end if;
            H.Data[0] <=> H.Data[H.Size - 1];
            const To_Return <== H.Data[H.Size - 1];
            H.Size -= 1;
            Preserve_Order_Down(H, 0);
            return To_Return;
        end func Pop;

        func To_String(H : Heap) -> Univ_String<> is
            return "[" | H.To_String_Helper(0, H.Size) | "]";
        end func To_String;

        //Fancy tree representation of Heap
        func To_String_Tree(locked H : Heap) -> Univ_String is
            //const H_Copy : Heap := H;
            var Strings : Str_Array := Str_Array::Create(0 ..< H.Size, "");
            const Elem_Size : Univ_Integer := H.To_Strings_Elem_Size(Strings);
            var Widths : Int_ZVector := Int_ZVector::Create(H.Size, 0);
            const Height := Tree_Height(Widths);
            var Col := 0;
            var Row := 0;
            var Result : ZString := "";
            const Root_Left_Blanks := Height - Row >= 1 ? Elem_Size * (2**(Height - Row - 1) - 1) : 0;
            Result |= " " * Root_Left_Blanks;
            for I in 0 ..< H.Size forward loop
                Col += 1;
                if Col == 1 then
                    Row += 1;
                end if;
                Result |= Strings[I];
                if Col == Widths[I] then
                    Result |= "\n";
                    const Left_Blanks := Height - Row >= 1 ? Elem_Size * (2**(Height - Row - 1) - 1) : 0;
                    Result |= " " * Left_Blanks;
                    Col := 0;
                else
                    const Inter_Blanks := Height - Row >= 0 ? Elem_Size * (2 * 2**(Height - Row) - 1) : 0;
                    Result |= " " * Inter_Blanks;
                end if;
            end loop
            return Result;
        end func To_String_Tree;
end class Heap;


func Test() is
    type Int_Heap is Heap<Univ_Integer>;
    var H : Int_Heap := Int_Heap::Create(#less);
    for J in 0 .. 3 concurrent loop
        for I in 0 .. 3 concurrent loop
            H |= I + J;
            Println(H.To_String_Tree());
        end loop;
    end loop;
    //for I in 0..<50 concurrent loop
    //    Print(H.Pop() | ", ");
    //end loop;
end func Test;
